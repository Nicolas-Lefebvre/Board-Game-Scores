import round from 'lodash/round';
import { PACKAGES_SEPARATOR, PACKAGE_ID_SEPARATOR } from '../config';
import { createGetMetricType } from '../utils/metrics';
import { metrics } from './metrics';
const HEX_HASH_PATTERN = '[a-f0-9]{5,32}';
const HEX_HASH_SEPARATOR_PATTERN = '[-_.~]';
const BASE64URL_HASH_PATTERN = '[A-Za-z0-9_-]{4,}';
const BASE64URL_SEPARATOR_PATTERN = '[.~]';
const EXTENSION_PATTERN = /(?:\.[a-z0-9]{2,}){1,}/;
const PATTERNS = [
    `(.*)${HEX_HASH_SEPARATOR_PATTERN}${HEX_HASH_PATTERN}(${EXTENSION_PATTERN.source})$`,
    `(static)/${HEX_HASH_PATTERN}(.*${EXTENSION_PATTERN.source})$`,
    `(.*)${BASE64URL_SEPARATOR_PATTERN}${BASE64URL_HASH_PATTERN}(${EXTENSION_PATTERN.source})$`,
].map((pattern) => new RegExp(pattern));
const NO_BASENAME = /(^|.*\/)\..*$/;
export const getAssetName = (statsAssetPath) => {
    if (!statsAssetPath) {
        return '';
    }
    for (let i = 0; i < PATTERNS.length; i += 1) {
        const pattern = PATTERNS[i];
        const extracted = statsAssetPath.replace(pattern, '$1$2');
        if (extracted && extracted !== statsAssetPath && !NO_BASENAME.test(extracted)) {
            return extracted;
        }
    }
    return statsAssetPath;
};
const NAME_WITH_LOADERS = /!/;
const NAME_WITH_MODULES = /\s?\+\s?\d*\s?modules$/;
const INVALID_CSS_PREFIX = /^css\s.*node_modules(?!\/)/;
export const getModuleName = (name) => {
    if (!name) {
        return '';
    }
    if (NAME_WITH_LOADERS.test(name)) {
        const segments = name.split(NAME_WITH_LOADERS);
        const normalizedName = segments[segments.length - 1];
        if (normalizedName === null || normalizedName === void 0 ? void 0 : normalizedName.trim()) {
            return normalizedName;
        }
    }
    if (NAME_WITH_MODULES.test(name)) {
        return name.replace(NAME_WITH_MODULES, '');
    }
    if (INVALID_CSS_PREFIX.test(name)) {
        return name.replace(INVALID_CSS_PREFIX, '');
    }
    return name;
};
export const calculateCacheInvalidation = (rows) => {
    let cached = 0;
    let invalidated = 0;
    rows.forEach(({ changed, added, deleted, runs }) => {
        if (added || deleted) {
            return;
        }
        if (changed) {
            invalidated += runs[1].value;
        }
        cached += runs[1].value;
    });
    if (cached === 0) {
        return 0;
    }
    return round((invalidated / cached) * 100, 2);
};
export const getMetricAdded = (runs) => {
    const [current, baseline] = (runs === null || runs === void 0 ? void 0 : runs.map((run) => run === null || run === void 0 ? void 0 : run.value)) || [];
    return Boolean(current !== null && !baseline);
};
export const getMetricDeleted = (runs) => {
    const [current, baseline] = (runs === null || runs === void 0 ? void 0 : runs.map((run) => run === null || run === void 0 ? void 0 : run.value)) || [];
    return Boolean(baseline !== null && !current);
};
export const getMetricType = createGetMetricType(metrics);
export const getPackagePublicName = (packageId) => {
    const packageNames = packageId.split(PACKAGES_SEPARATOR);
    const name = packageNames[packageNames.length - 1];
    return name.split(PACKAGE_ID_SEPARATOR)[0];
};
export const normalizeChunkId = (chunkId) => chunkId.toString();
//# sourceMappingURL=utils.js.map