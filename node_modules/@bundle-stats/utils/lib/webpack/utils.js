"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeChunkId = exports.getPackagePublicName = exports.getMetricType = exports.getMetricDeleted = exports.getMetricAdded = exports.calculateCacheInvalidation = exports.getModuleName = exports.getAssetName = void 0;
const round_1 = __importDefault(require("lodash/round"));
const config_1 = require("../config");
const metrics_1 = require("../utils/metrics");
const metrics_2 = require("./metrics");
const HEX_HASH_PATTERN = '[a-f0-9]{5,32}';
const HEX_HASH_SEPARATOR_PATTERN = '[-_.~]';
const BASE64URL_HASH_PATTERN = '[A-Za-z0-9_-]{4,}';
const BASE64URL_SEPARATOR_PATTERN = '[.~]';
const EXTENSION_PATTERN = /(?:\.[a-z0-9]{2,}){1,}/;
const PATTERNS = [
    `(.*)${HEX_HASH_SEPARATOR_PATTERN}${HEX_HASH_PATTERN}(${EXTENSION_PATTERN.source})$`,
    `(static)/${HEX_HASH_PATTERN}(.*${EXTENSION_PATTERN.source})$`,
    `(.*)${BASE64URL_SEPARATOR_PATTERN}${BASE64URL_HASH_PATTERN}(${EXTENSION_PATTERN.source})$`,
].map((pattern) => new RegExp(pattern));
const NO_BASENAME = /(^|.*\/)\..*$/;
const getAssetName = (statsAssetPath) => {
    if (!statsAssetPath) {
        return '';
    }
    for (let i = 0; i < PATTERNS.length; i += 1) {
        const pattern = PATTERNS[i];
        const extracted = statsAssetPath.replace(pattern, '$1$2');
        if (extracted && extracted !== statsAssetPath && !NO_BASENAME.test(extracted)) {
            return extracted;
        }
    }
    return statsAssetPath;
};
exports.getAssetName = getAssetName;
const NAME_WITH_LOADERS = /!/;
const NAME_WITH_MODULES = /\s?\+\s?\d*\s?modules$/;
const INVALID_CSS_PREFIX = /^css\s.*node_modules(?!\/)/;
const getModuleName = (name) => {
    if (!name) {
        return '';
    }
    if (NAME_WITH_LOADERS.test(name)) {
        const segments = name.split(NAME_WITH_LOADERS);
        const normalizedName = segments[segments.length - 1];
        if (normalizedName?.trim()) {
            return normalizedName;
        }
    }
    if (NAME_WITH_MODULES.test(name)) {
        return name.replace(NAME_WITH_MODULES, '');
    }
    if (INVALID_CSS_PREFIX.test(name)) {
        return name.replace(INVALID_CSS_PREFIX, '');
    }
    return name;
};
exports.getModuleName = getModuleName;
const calculateCacheInvalidation = (rows) => {
    let cached = 0;
    let invalidated = 0;
    rows.forEach(({ changed, added, deleted, runs }) => {
        if (added || deleted) {
            return;
        }
        if (changed) {
            invalidated += runs[1].value;
        }
        cached += runs[1].value;
    });
    if (cached === 0) {
        return 0;
    }
    return (0, round_1.default)((invalidated / cached) * 100, 2);
};
exports.calculateCacheInvalidation = calculateCacheInvalidation;
const getMetricAdded = (runs) => {
    const [current, baseline] = runs?.map((run) => run?.value) || [];
    return Boolean(current !== null && !baseline);
};
exports.getMetricAdded = getMetricAdded;
const getMetricDeleted = (runs) => {
    const [current, baseline] = runs?.map((run) => run?.value) || [];
    return Boolean(baseline !== null && !current);
};
exports.getMetricDeleted = getMetricDeleted;
exports.getMetricType = (0, metrics_1.createGetMetricType)(metrics_2.metrics);
const getPackagePublicName = (packageId) => {
    const packageNames = packageId.split(config_1.PACKAGES_SEPARATOR);
    const name = packageNames[packageNames.length - 1];
    return name.split(config_1.PACKAGE_ID_SEPARATOR)[0];
};
exports.getPackagePublicName = getPackagePublicName;
const normalizeChunkId = (chunkId) => chunkId.toString();
exports.normalizeChunkId = normalizeChunkId;
//# sourceMappingURL=utils.js.map